# 4.1 - Identifier

##  AGENDA

* Why syntatic identifiers are usually prefered.
* All JPA identifier generators, IDENTITY, SEQUENCE, TABLE and AUTO


## Database primary keys 

In Relation database wourld, the primary key is used to uniquely identify a table row. 
When it cames to choosing a Primary key there ara basically two options:

- natural key
- surrogate key

### natural key

* A Natural key is for example the Social security number, vehicle identification number or a book ISBN.

* Is assigned by a central organization who guarantees that can't exists two equals keys.

* The major problem with Natural keys is its size. In order to be unique, the natural ID is rather Long.

    - Social security number: 9 digits
    
    - Book ISBN: 10 or 13 digits
    
    - vehicle identifier Number: 17 alphanumeric characters

That is going to take a significant amount of space in the database. 
It's not just the primary key that will take a lots of space, we have also the all Foreign keys linking back to a particular natural identifier.


The Alternative is to use a Surrogate keys. 


### Surrogate keys

we have some examples of sorrogate keys.

* UUID
	
	suffers from the same issue as the natural keys, its Takes a lotes of space. Taking 128 bits, it's quite large.

* auto-increment numeric sequence

	column can be mush more compact. Dependending on how many rows we need to insert into the table, we can choose:

	- TINYINT: 1 byte, max of 256 rows.
	- SMALLINT: 2 bytes, max 65000 rows
	- INT: 4 bytes, max 4 billion rows.
	- BIGINT: 8 bytes, and you won't ever run out of identifier values.

* The more compact the identifier are, less space it will take to store a row on the disk, or memory when the associated page is store in the database buffer pool. 


* the more compact the identifier are, more effecient the index will be. 

* when come to PK and FK we will probably want to index all these keys to spped up queries invoking the PK or FK.

	In my MySQL secondary index reference the primary key, so if PK is large, all secondary indexes will be affected as well.

	Numeric identifiers are more suitable to clustered index as well. 

	A clustered index is an index- organized table meaning that the table it self is stored as an index, where the PK is used to build the index. The most common relation database index, the B-Tree is a self-balancing tree data structure this means that when the keys are added in a random order there is going to be a lot of fragmentation and page splits.
	However, when using sequential numeric values records are always appended at the end of the clustered index, so the physical ordering of the index pages is going to match the logical ordering of the index nodes. Therefore, searching a range of primary keys, like it is the case of keyset pagination, can be done sequentially, and it is going to be very fast. 

	If the PK values are scattered all over the entire index tree, the physical page ordering is going to be different than the logical ordering of the index nodes. So, scanning the index will incur more random I/O than sequential reads, so it is going to be slower.


---


# JPA Identifiers generator.

In JPA every entity must have an identifier (@Id), therefore the entity table must contain a PK column that is mapped to the property annotated with the @Id annotation.

The identifier can be assigned manually or automatically generated by the JPA provider.


To generate the Identifiers automatically we have 3 basic strategies:

* **IDENTITY** - using an database identity column

* **SEQUENCE** - using an database sequence generator,

* **TABLE** - emulating a database sequence using a separate table.

JPA provide an other strategy:

* **AUT0** - when we use auto, the Hibernate chooses one of the three previous strategies.  

To define a automatically strategy we must provide the @GeneratedValue annotation to the the property annotated with the @Id annotation.
Otherwise the user must supply a unique whenever a new entity instance is persisted.



# IDENTITY generator

* The IDENTITY column type (included in the SQL:2002 standard) is supported by SQL Server, MYSQL, Oracle(since version 12c) and Postgres.

* Can only be applied to a single column of the a table.

* The column value can be assigned automatically to the current value of an iternal counter that is incremented every time that is invoked.

* The previous described incrementation process is very efficient since it uses a lightweight locking mechanism. 

* The counter is not transactional, this means that it will be always incremented given when the statement result in a rollback. Note this is a feature, not a bug.


```java
@Entity
class Developer {
    
	@Id
	@GeneratedValue(
			strategy = GeneratedType.INDENTITY
		)
	private Long id;
    
	// Other properties ...
}
```

When we persist a new entity the Hibernate is going to use the **DEFAULT** keyword for the PK and the database is going to allocate a new value after incrementing the **IDENTITY** column counter.


```sql
INSERT INTO developer (id, name) VALUES (DEFAULT, 'Duke')
```

The disadvantage of this strategy is that the newly assigned value can only be know after the actual INSERT statement is executed.

Hibernate separates the id generation from the actual entity INSERT statement, entities using the IDENTITY generator can not be inserted in batches. because the INSERT Statement is executes right away when the persist method is invoked.


# 	SEQUENCE generator

* A SEQUENCE is a database object that generates numbers upon incrementing an internal counter.

* The same SEQUENCE can be used to populate multiple columns, even across tables. Or we can use it just to generate unique values that can be used by the application outside of the relation database.

* Allows incremental steps, a SEQUENCE can benefit from application-level optimization techniques.

* Because the SEQUENCE call can be decoupled from the actual INSERT statement, entities can be inserted in batches during the Persistence Context flush operation.

* If we do not define the sequence generator the hibernate is going to define a sequence for us.

```java
@Entity
// Define a sequence - might also be in another class:
@SequenceGenerator(
    name = "developer_id_generator", 
    sequenceName = "developer_seq_generator", 
    initialValue = 1, 
    allocationSize = 100 // The amount to increment by when allocating sequence numbers from the sequence.
)
public class Developer {
    
	@Id
	@GeneratedValue(
			strategy = GeneratedType.SEQUENCE,
			generator="developer_id_generator"
		)
	private Long id;
    	
	// Other properties ...
}
```

Like IDENTITY columns, database sequences use dedicated locks to prevent concurrent transactions from acquiring the same value. Since locks are released right after incrementing the associated counter, a gap can occur between the PK value of two consecutive table row. this is not problem since that PK values need to be unique, not to form serie of consecutive integer values.


# TABLE generator

* JPA offers an alternative sequence-like generator that works even when database SEQUENCE objects are not natively supported.

* A database table is used to hold the latest sequence value and row-level locking is employed to prevent two concurrent connections from acquiring the same identifier value.


```java
@Entity
public class Developer {
    @Id
    @GeneratedValue(
		strategy = GenerationType.TABLE 
	)
	private Long id;
    
    //Getters and setters omitted for brevity
}
```

1.  For the TABLE identifier generator, Hibernate is going to use a separate database table to hold the current sequence value.

2. when persisting a entity the current value is fetched while also locking the underlying TABLE generator record.

3. If the table generator does not find any associated record one is insertedwith value of 1. 


```sql
SELECT tbl.next_val
FROM hibernate_sequences tbl
WHERE tbl.sequence_name = 'default' FOR UPDATE;


-- 3
INSERT INTO hibernate_sequences (sequence_name, next_val) 
	VALUES ('default', 1);

UPDATE hibernate_sequences 
	SET next_val = 2 WHERE next_val = 1 AND sequence_name = 'default';

SELECT tbl.next_val
FROM hibernate_sequences tbl
WHERE tbl.sequence_name = 'default' FOR UPDATE

UPDATE hibernate_sequences SET next_val = 3 
	WHERE next_val = 2 
	AND sequence_name = 'default’;


SELECT tbl.next_val
	FROM hibernate_sequences tbl
WHERE tbl.sequence_name = 'default' FOR UPDATE;

UPDATE hibernate_sequences 
	SET next_val = 4 
WHERE next_val = 3 
AND sequence_name = 'default’;

INSERT INTO developer (name, id)
VALUES ('A', 1)
INSERT INTO post (name, id)
VALUES ('B', 2)
INSERT INTO post (name, id)
VALUES ('C', 3)

```

Using a database table as a sequence is challenging, because:

* to prevent 2 transactions from getting the same sequence value, row-level locking must be used.

* unlike the sequence objects locks, a row-level lock is transactional, and once acquired it can only be released when the current transaction ends, either by issuing a commit or a rollback.

* To cope with this limitation a separate database transaction is used for fetching a new sequence value. This way the row-level lock associated with the sequence counter value incrementation process can be released as soon as the identifier value is returned to the calling thread.



## For RESOURCE_LOCAL transactions

A new transaction implies:

1. acquiring a separate database connection,
2. disabling the auto-commit flag,
3. executing the sequence processing logic, and finally
4. committing this secondary database transaction.

This can put additional pressure on the underlying connection pool, especially if there is already a significant contention for database connections.



## For JTA transactions

1. The current running transaction must be suspended
2. the sequence value is fetched in a separate transaction.
3. the calling transaction is resumed after the new sequence value is acquired.



# AUTO generator

This is the default value of the JPA @GeneratedValue

```java
@Entity
public class Developer {
    
    @Id
    @GeneratedValue(
		strategy = GenerationType.AUTO 
	)
	private Long id;
}
```


So, the million dolor question is: **what identifier generator should we chose?**


## Prior to Hibernate 5, 

the native generator was used when employing the AUTO identifier generator strategy.

The native generator works as follows:
* The native generator will pick IDENTITY if database supports identity columns. This is, If the RDBMS (Relational Database Management System) supports IDENTITY columns, then IDENTITY is used.
* Otherwise, the SEQUENCE generator is being employed.


This can be a problem for database like PostgresSQL or Oracle 12c. Since to benefit from batched inserts, we want to use SEQUENCE objects even if IDENTITY columns are supported as well.


## Since Hibernate 5, 

The AUTO generator falls back to using Hibernate SequenceStyleGenerator, which works as following:

* If the RDBMS supports SEQUENCE objects, then the SEQUENCE strategy is
used.
* Otherwise, the TABLE generator is being employed.


however this new behavior is not desirable for a database like MySQL as long as sequence objects are not supported natively.
So to avoid the use of the TABLE generator we have to instructing hibernate to use the native generator instead, as hibernate is going to pick the IDENTITY generator and not the TABLE generator. 

```java
@Id
@GeneratedValue(generator="native") 
@GenericGenerator(name = "native", strategy = "native") 
private Long id;
``` 

So when inserting the same 3 Developer entities on MySql, hibernate will execute the following SQL INSERT statements. Note that the use of the DEFAULT keyword is database-specific. this is, Hibernate will use it FOR Hypersonic, but omit it for MySQL.


```sql
INSERT INTO developer (title) VALUES ('A');

INSERT INTO developer (title) VALUES ('B')

INSERT INTO developer (title) VALUES ('C')
```


---

# what about if we need to use UUID as primary key?

Hibernate provides proprietary support for attributes of type **java.util.UUID** as primary keys and offers two generators to create UUID values. The generators support the standards IETF RFC 4122 version 4 and IETF RFC 4122 version 1.


IETF RFC 4122 version 4 --- Random number-based UUID By default, Hibernate uses a random number-based generation strategy. As always, you don’t have to do much to get the default behavior. You just need to add a @GeneratedValue annotation to a primary key attribute of type java.util.UUID.

You can see an example of it in the following code snippet.

```java
@Entity
public class Developer {
    @Id
    @GeneratedValue
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;
    // ...
}
```

When you now persist a new Developer entity, Hibernate generates a UUID before writing the new record to the database.

```sql
insert into Developer (firstName, lastName, version, id) values (?, ?, ?, ?)

```

IETF RFC 4122 version 1 --- IP- and timestamp-based UUID Hibernate can also generate a UUID based on the IP and timestamp as defined by IETF RFC 4122 version 1. But the configuration of it requires an additional annotation.
You need to annotate a primary key attribute of type java.util.UUID with @GeneratedValue annotation that references a custom ID generator by its name. The ID generator defines the strategy Hibernate uses to generate the primary key value. You can define it with Hibernate’s @GenericGenerator annotations. Itrequires the name of the generator, the name of the class that implements the 50 How to use a


```
@Entity
public class Developer {
    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(
        name = "UUID",
        strategy = "org.hibernate.id.UUIDGenerator",
        parameters = {
                @Parameter(
                name = "uuid_gen_strategy_class",
                value = "org.hibernate.id.uuid.CustomVersionOneStrategy"
     )
     }
    )
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;
...
}
```


Hibernate uses this mapping definition in the same way as in the previous example. It just uses a different algorithm to generate the UUID before it stores the new Book entity in the database.